// Code generated by counterfeiter. DO NOT EDIT.
package usergroupfakes

import (
	"sync"

	pivnet "github.com/pivotal-cf/go-pivnet/v7"
	"github.com/pivotal-cf/pivnet-cli/v3/commands/usergroup"
)

type FakePivnetClient struct {
	AddMemberToGroupStub        func(int, string, bool) (pivnet.UserGroup, error)
	addMemberToGroupMutex       sync.RWMutex
	addMemberToGroupArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 bool
	}
	addMemberToGroupReturns struct {
		result1 pivnet.UserGroup
		result2 error
	}
	addMemberToGroupReturnsOnCall map[int]struct {
		result1 pivnet.UserGroup
		result2 error
	}
	AddUserGroupStub        func(string, int, int) error
	addUserGroupMutex       sync.RWMutex
	addUserGroupArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	addUserGroupReturns struct {
		result1 error
	}
	addUserGroupReturnsOnCall map[int]struct {
		result1 error
	}
	CreateUserGroupStub        func(string, string, []string) (pivnet.UserGroup, error)
	createUserGroupMutex       sync.RWMutex
	createUserGroupArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []string
	}
	createUserGroupReturns struct {
		result1 pivnet.UserGroup
		result2 error
	}
	createUserGroupReturnsOnCall map[int]struct {
		result1 pivnet.UserGroup
		result2 error
	}
	DeleteUserGroupStub        func(int) error
	deleteUserGroupMutex       sync.RWMutex
	deleteUserGroupArgsForCall []struct {
		arg1 int
	}
	deleteUserGroupReturns struct {
		result1 error
	}
	deleteUserGroupReturnsOnCall map[int]struct {
		result1 error
	}
	ReleaseForVersionStub        func(string, string) (pivnet.Release, error)
	releaseForVersionMutex       sync.RWMutex
	releaseForVersionArgsForCall []struct {
		arg1 string
		arg2 string
	}
	releaseForVersionReturns struct {
		result1 pivnet.Release
		result2 error
	}
	releaseForVersionReturnsOnCall map[int]struct {
		result1 pivnet.Release
		result2 error
	}
	RemoveMemberFromGroupStub        func(int, string) (pivnet.UserGroup, error)
	removeMemberFromGroupMutex       sync.RWMutex
	removeMemberFromGroupArgsForCall []struct {
		arg1 int
		arg2 string
	}
	removeMemberFromGroupReturns struct {
		result1 pivnet.UserGroup
		result2 error
	}
	removeMemberFromGroupReturnsOnCall map[int]struct {
		result1 pivnet.UserGroup
		result2 error
	}
	RemoveUserGroupStub        func(string, int, int) error
	removeUserGroupMutex       sync.RWMutex
	removeUserGroupArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	removeUserGroupReturns struct {
		result1 error
	}
	removeUserGroupReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateUserGroupStub        func(pivnet.UserGroup) (pivnet.UserGroup, error)
	updateUserGroupMutex       sync.RWMutex
	updateUserGroupArgsForCall []struct {
		arg1 pivnet.UserGroup
	}
	updateUserGroupReturns struct {
		result1 pivnet.UserGroup
		result2 error
	}
	updateUserGroupReturnsOnCall map[int]struct {
		result1 pivnet.UserGroup
		result2 error
	}
	UserGroupStub        func(int) (pivnet.UserGroup, error)
	userGroupMutex       sync.RWMutex
	userGroupArgsForCall []struct {
		arg1 int
	}
	userGroupReturns struct {
		result1 pivnet.UserGroup
		result2 error
	}
	userGroupReturnsOnCall map[int]struct {
		result1 pivnet.UserGroup
		result2 error
	}
	UserGroupsStub        func() ([]pivnet.UserGroup, error)
	userGroupsMutex       sync.RWMutex
	userGroupsArgsForCall []struct {
	}
	userGroupsReturns struct {
		result1 []pivnet.UserGroup
		result2 error
	}
	userGroupsReturnsOnCall map[int]struct {
		result1 []pivnet.UserGroup
		result2 error
	}
	UserGroupsForReleaseStub        func(string, int) ([]pivnet.UserGroup, error)
	userGroupsForReleaseMutex       sync.RWMutex
	userGroupsForReleaseArgsForCall []struct {
		arg1 string
		arg2 int
	}
	userGroupsForReleaseReturns struct {
		result1 []pivnet.UserGroup
		result2 error
	}
	userGroupsForReleaseReturnsOnCall map[int]struct {
		result1 []pivnet.UserGroup
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePivnetClient) AddMemberToGroup(arg1 int, arg2 string, arg3 bool) (pivnet.UserGroup, error) {
	fake.addMemberToGroupMutex.Lock()
	ret, specificReturn := fake.addMemberToGroupReturnsOnCall[len(fake.addMemberToGroupArgsForCall)]
	fake.addMemberToGroupArgsForCall = append(fake.addMemberToGroupArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("AddMemberToGroup", []interface{}{arg1, arg2, arg3})
	fake.addMemberToGroupMutex.Unlock()
	if fake.AddMemberToGroupStub != nil {
		return fake.AddMemberToGroupStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.addMemberToGroupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) AddMemberToGroupCallCount() int {
	fake.addMemberToGroupMutex.RLock()
	defer fake.addMemberToGroupMutex.RUnlock()
	return len(fake.addMemberToGroupArgsForCall)
}

func (fake *FakePivnetClient) AddMemberToGroupCalls(stub func(int, string, bool) (pivnet.UserGroup, error)) {
	fake.addMemberToGroupMutex.Lock()
	defer fake.addMemberToGroupMutex.Unlock()
	fake.AddMemberToGroupStub = stub
}

func (fake *FakePivnetClient) AddMemberToGroupArgsForCall(i int) (int, string, bool) {
	fake.addMemberToGroupMutex.RLock()
	defer fake.addMemberToGroupMutex.RUnlock()
	argsForCall := fake.addMemberToGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePivnetClient) AddMemberToGroupReturns(result1 pivnet.UserGroup, result2 error) {
	fake.addMemberToGroupMutex.Lock()
	defer fake.addMemberToGroupMutex.Unlock()
	fake.AddMemberToGroupStub = nil
	fake.addMemberToGroupReturns = struct {
		result1 pivnet.UserGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) AddMemberToGroupReturnsOnCall(i int, result1 pivnet.UserGroup, result2 error) {
	fake.addMemberToGroupMutex.Lock()
	defer fake.addMemberToGroupMutex.Unlock()
	fake.AddMemberToGroupStub = nil
	if fake.addMemberToGroupReturnsOnCall == nil {
		fake.addMemberToGroupReturnsOnCall = make(map[int]struct {
			result1 pivnet.UserGroup
			result2 error
		})
	}
	fake.addMemberToGroupReturnsOnCall[i] = struct {
		result1 pivnet.UserGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) AddUserGroup(arg1 string, arg2 int, arg3 int) error {
	fake.addUserGroupMutex.Lock()
	ret, specificReturn := fake.addUserGroupReturnsOnCall[len(fake.addUserGroupArgsForCall)]
	fake.addUserGroupArgsForCall = append(fake.addUserGroupArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("AddUserGroup", []interface{}{arg1, arg2, arg3})
	fake.addUserGroupMutex.Unlock()
	if fake.AddUserGroupStub != nil {
		return fake.AddUserGroupStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.addUserGroupReturns
	return fakeReturns.result1
}

func (fake *FakePivnetClient) AddUserGroupCallCount() int {
	fake.addUserGroupMutex.RLock()
	defer fake.addUserGroupMutex.RUnlock()
	return len(fake.addUserGroupArgsForCall)
}

func (fake *FakePivnetClient) AddUserGroupCalls(stub func(string, int, int) error) {
	fake.addUserGroupMutex.Lock()
	defer fake.addUserGroupMutex.Unlock()
	fake.AddUserGroupStub = stub
}

func (fake *FakePivnetClient) AddUserGroupArgsForCall(i int) (string, int, int) {
	fake.addUserGroupMutex.RLock()
	defer fake.addUserGroupMutex.RUnlock()
	argsForCall := fake.addUserGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePivnetClient) AddUserGroupReturns(result1 error) {
	fake.addUserGroupMutex.Lock()
	defer fake.addUserGroupMutex.Unlock()
	fake.AddUserGroupStub = nil
	fake.addUserGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) AddUserGroupReturnsOnCall(i int, result1 error) {
	fake.addUserGroupMutex.Lock()
	defer fake.addUserGroupMutex.Unlock()
	fake.AddUserGroupStub = nil
	if fake.addUserGroupReturnsOnCall == nil {
		fake.addUserGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addUserGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) CreateUserGroup(arg1 string, arg2 string, arg3 []string) (pivnet.UserGroup, error) {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.createUserGroupMutex.Lock()
	ret, specificReturn := fake.createUserGroupReturnsOnCall[len(fake.createUserGroupArgsForCall)]
	fake.createUserGroupArgsForCall = append(fake.createUserGroupArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3Copy})
	fake.recordInvocation("CreateUserGroup", []interface{}{arg1, arg2, arg3Copy})
	fake.createUserGroupMutex.Unlock()
	if fake.CreateUserGroupStub != nil {
		return fake.CreateUserGroupStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createUserGroupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) CreateUserGroupCallCount() int {
	fake.createUserGroupMutex.RLock()
	defer fake.createUserGroupMutex.RUnlock()
	return len(fake.createUserGroupArgsForCall)
}

func (fake *FakePivnetClient) CreateUserGroupCalls(stub func(string, string, []string) (pivnet.UserGroup, error)) {
	fake.createUserGroupMutex.Lock()
	defer fake.createUserGroupMutex.Unlock()
	fake.CreateUserGroupStub = stub
}

func (fake *FakePivnetClient) CreateUserGroupArgsForCall(i int) (string, string, []string) {
	fake.createUserGroupMutex.RLock()
	defer fake.createUserGroupMutex.RUnlock()
	argsForCall := fake.createUserGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePivnetClient) CreateUserGroupReturns(result1 pivnet.UserGroup, result2 error) {
	fake.createUserGroupMutex.Lock()
	defer fake.createUserGroupMutex.Unlock()
	fake.CreateUserGroupStub = nil
	fake.createUserGroupReturns = struct {
		result1 pivnet.UserGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) CreateUserGroupReturnsOnCall(i int, result1 pivnet.UserGroup, result2 error) {
	fake.createUserGroupMutex.Lock()
	defer fake.createUserGroupMutex.Unlock()
	fake.CreateUserGroupStub = nil
	if fake.createUserGroupReturnsOnCall == nil {
		fake.createUserGroupReturnsOnCall = make(map[int]struct {
			result1 pivnet.UserGroup
			result2 error
		})
	}
	fake.createUserGroupReturnsOnCall[i] = struct {
		result1 pivnet.UserGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) DeleteUserGroup(arg1 int) error {
	fake.deleteUserGroupMutex.Lock()
	ret, specificReturn := fake.deleteUserGroupReturnsOnCall[len(fake.deleteUserGroupArgsForCall)]
	fake.deleteUserGroupArgsForCall = append(fake.deleteUserGroupArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("DeleteUserGroup", []interface{}{arg1})
	fake.deleteUserGroupMutex.Unlock()
	if fake.DeleteUserGroupStub != nil {
		return fake.DeleteUserGroupStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteUserGroupReturns
	return fakeReturns.result1
}

func (fake *FakePivnetClient) DeleteUserGroupCallCount() int {
	fake.deleteUserGroupMutex.RLock()
	defer fake.deleteUserGroupMutex.RUnlock()
	return len(fake.deleteUserGroupArgsForCall)
}

func (fake *FakePivnetClient) DeleteUserGroupCalls(stub func(int) error) {
	fake.deleteUserGroupMutex.Lock()
	defer fake.deleteUserGroupMutex.Unlock()
	fake.DeleteUserGroupStub = stub
}

func (fake *FakePivnetClient) DeleteUserGroupArgsForCall(i int) int {
	fake.deleteUserGroupMutex.RLock()
	defer fake.deleteUserGroupMutex.RUnlock()
	argsForCall := fake.deleteUserGroupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePivnetClient) DeleteUserGroupReturns(result1 error) {
	fake.deleteUserGroupMutex.Lock()
	defer fake.deleteUserGroupMutex.Unlock()
	fake.DeleteUserGroupStub = nil
	fake.deleteUserGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) DeleteUserGroupReturnsOnCall(i int, result1 error) {
	fake.deleteUserGroupMutex.Lock()
	defer fake.deleteUserGroupMutex.Unlock()
	fake.DeleteUserGroupStub = nil
	if fake.deleteUserGroupReturnsOnCall == nil {
		fake.deleteUserGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteUserGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) ReleaseForVersion(arg1 string, arg2 string) (pivnet.Release, error) {
	fake.releaseForVersionMutex.Lock()
	ret, specificReturn := fake.releaseForVersionReturnsOnCall[len(fake.releaseForVersionArgsForCall)]
	fake.releaseForVersionArgsForCall = append(fake.releaseForVersionArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ReleaseForVersion", []interface{}{arg1, arg2})
	fake.releaseForVersionMutex.Unlock()
	if fake.ReleaseForVersionStub != nil {
		return fake.ReleaseForVersionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.releaseForVersionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) ReleaseForVersionCallCount() int {
	fake.releaseForVersionMutex.RLock()
	defer fake.releaseForVersionMutex.RUnlock()
	return len(fake.releaseForVersionArgsForCall)
}

func (fake *FakePivnetClient) ReleaseForVersionCalls(stub func(string, string) (pivnet.Release, error)) {
	fake.releaseForVersionMutex.Lock()
	defer fake.releaseForVersionMutex.Unlock()
	fake.ReleaseForVersionStub = stub
}

func (fake *FakePivnetClient) ReleaseForVersionArgsForCall(i int) (string, string) {
	fake.releaseForVersionMutex.RLock()
	defer fake.releaseForVersionMutex.RUnlock()
	argsForCall := fake.releaseForVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) ReleaseForVersionReturns(result1 pivnet.Release, result2 error) {
	fake.releaseForVersionMutex.Lock()
	defer fake.releaseForVersionMutex.Unlock()
	fake.ReleaseForVersionStub = nil
	fake.releaseForVersionReturns = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ReleaseForVersionReturnsOnCall(i int, result1 pivnet.Release, result2 error) {
	fake.releaseForVersionMutex.Lock()
	defer fake.releaseForVersionMutex.Unlock()
	fake.ReleaseForVersionStub = nil
	if fake.releaseForVersionReturnsOnCall == nil {
		fake.releaseForVersionReturnsOnCall = make(map[int]struct {
			result1 pivnet.Release
			result2 error
		})
	}
	fake.releaseForVersionReturnsOnCall[i] = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) RemoveMemberFromGroup(arg1 int, arg2 string) (pivnet.UserGroup, error) {
	fake.removeMemberFromGroupMutex.Lock()
	ret, specificReturn := fake.removeMemberFromGroupReturnsOnCall[len(fake.removeMemberFromGroupArgsForCall)]
	fake.removeMemberFromGroupArgsForCall = append(fake.removeMemberFromGroupArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("RemoveMemberFromGroup", []interface{}{arg1, arg2})
	fake.removeMemberFromGroupMutex.Unlock()
	if fake.RemoveMemberFromGroupStub != nil {
		return fake.RemoveMemberFromGroupStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.removeMemberFromGroupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) RemoveMemberFromGroupCallCount() int {
	fake.removeMemberFromGroupMutex.RLock()
	defer fake.removeMemberFromGroupMutex.RUnlock()
	return len(fake.removeMemberFromGroupArgsForCall)
}

func (fake *FakePivnetClient) RemoveMemberFromGroupCalls(stub func(int, string) (pivnet.UserGroup, error)) {
	fake.removeMemberFromGroupMutex.Lock()
	defer fake.removeMemberFromGroupMutex.Unlock()
	fake.RemoveMemberFromGroupStub = stub
}

func (fake *FakePivnetClient) RemoveMemberFromGroupArgsForCall(i int) (int, string) {
	fake.removeMemberFromGroupMutex.RLock()
	defer fake.removeMemberFromGroupMutex.RUnlock()
	argsForCall := fake.removeMemberFromGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) RemoveMemberFromGroupReturns(result1 pivnet.UserGroup, result2 error) {
	fake.removeMemberFromGroupMutex.Lock()
	defer fake.removeMemberFromGroupMutex.Unlock()
	fake.RemoveMemberFromGroupStub = nil
	fake.removeMemberFromGroupReturns = struct {
		result1 pivnet.UserGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) RemoveMemberFromGroupReturnsOnCall(i int, result1 pivnet.UserGroup, result2 error) {
	fake.removeMemberFromGroupMutex.Lock()
	defer fake.removeMemberFromGroupMutex.Unlock()
	fake.RemoveMemberFromGroupStub = nil
	if fake.removeMemberFromGroupReturnsOnCall == nil {
		fake.removeMemberFromGroupReturnsOnCall = make(map[int]struct {
			result1 pivnet.UserGroup
			result2 error
		})
	}
	fake.removeMemberFromGroupReturnsOnCall[i] = struct {
		result1 pivnet.UserGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) RemoveUserGroup(arg1 string, arg2 int, arg3 int) error {
	fake.removeUserGroupMutex.Lock()
	ret, specificReturn := fake.removeUserGroupReturnsOnCall[len(fake.removeUserGroupArgsForCall)]
	fake.removeUserGroupArgsForCall = append(fake.removeUserGroupArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("RemoveUserGroup", []interface{}{arg1, arg2, arg3})
	fake.removeUserGroupMutex.Unlock()
	if fake.RemoveUserGroupStub != nil {
		return fake.RemoveUserGroupStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeUserGroupReturns
	return fakeReturns.result1
}

func (fake *FakePivnetClient) RemoveUserGroupCallCount() int {
	fake.removeUserGroupMutex.RLock()
	defer fake.removeUserGroupMutex.RUnlock()
	return len(fake.removeUserGroupArgsForCall)
}

func (fake *FakePivnetClient) RemoveUserGroupCalls(stub func(string, int, int) error) {
	fake.removeUserGroupMutex.Lock()
	defer fake.removeUserGroupMutex.Unlock()
	fake.RemoveUserGroupStub = stub
}

func (fake *FakePivnetClient) RemoveUserGroupArgsForCall(i int) (string, int, int) {
	fake.removeUserGroupMutex.RLock()
	defer fake.removeUserGroupMutex.RUnlock()
	argsForCall := fake.removeUserGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePivnetClient) RemoveUserGroupReturns(result1 error) {
	fake.removeUserGroupMutex.Lock()
	defer fake.removeUserGroupMutex.Unlock()
	fake.RemoveUserGroupStub = nil
	fake.removeUserGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) RemoveUserGroupReturnsOnCall(i int, result1 error) {
	fake.removeUserGroupMutex.Lock()
	defer fake.removeUserGroupMutex.Unlock()
	fake.RemoveUserGroupStub = nil
	if fake.removeUserGroupReturnsOnCall == nil {
		fake.removeUserGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeUserGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) UpdateUserGroup(arg1 pivnet.UserGroup) (pivnet.UserGroup, error) {
	fake.updateUserGroupMutex.Lock()
	ret, specificReturn := fake.updateUserGroupReturnsOnCall[len(fake.updateUserGroupArgsForCall)]
	fake.updateUserGroupArgsForCall = append(fake.updateUserGroupArgsForCall, struct {
		arg1 pivnet.UserGroup
	}{arg1})
	fake.recordInvocation("UpdateUserGroup", []interface{}{arg1})
	fake.updateUserGroupMutex.Unlock()
	if fake.UpdateUserGroupStub != nil {
		return fake.UpdateUserGroupStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateUserGroupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) UpdateUserGroupCallCount() int {
	fake.updateUserGroupMutex.RLock()
	defer fake.updateUserGroupMutex.RUnlock()
	return len(fake.updateUserGroupArgsForCall)
}

func (fake *FakePivnetClient) UpdateUserGroupCalls(stub func(pivnet.UserGroup) (pivnet.UserGroup, error)) {
	fake.updateUserGroupMutex.Lock()
	defer fake.updateUserGroupMutex.Unlock()
	fake.UpdateUserGroupStub = stub
}

func (fake *FakePivnetClient) UpdateUserGroupArgsForCall(i int) pivnet.UserGroup {
	fake.updateUserGroupMutex.RLock()
	defer fake.updateUserGroupMutex.RUnlock()
	argsForCall := fake.updateUserGroupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePivnetClient) UpdateUserGroupReturns(result1 pivnet.UserGroup, result2 error) {
	fake.updateUserGroupMutex.Lock()
	defer fake.updateUserGroupMutex.Unlock()
	fake.UpdateUserGroupStub = nil
	fake.updateUserGroupReturns = struct {
		result1 pivnet.UserGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) UpdateUserGroupReturnsOnCall(i int, result1 pivnet.UserGroup, result2 error) {
	fake.updateUserGroupMutex.Lock()
	defer fake.updateUserGroupMutex.Unlock()
	fake.UpdateUserGroupStub = nil
	if fake.updateUserGroupReturnsOnCall == nil {
		fake.updateUserGroupReturnsOnCall = make(map[int]struct {
			result1 pivnet.UserGroup
			result2 error
		})
	}
	fake.updateUserGroupReturnsOnCall[i] = struct {
		result1 pivnet.UserGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) UserGroup(arg1 int) (pivnet.UserGroup, error) {
	fake.userGroupMutex.Lock()
	ret, specificReturn := fake.userGroupReturnsOnCall[len(fake.userGroupArgsForCall)]
	fake.userGroupArgsForCall = append(fake.userGroupArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("UserGroup", []interface{}{arg1})
	fake.userGroupMutex.Unlock()
	if fake.UserGroupStub != nil {
		return fake.UserGroupStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.userGroupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) UserGroupCallCount() int {
	fake.userGroupMutex.RLock()
	defer fake.userGroupMutex.RUnlock()
	return len(fake.userGroupArgsForCall)
}

func (fake *FakePivnetClient) UserGroupCalls(stub func(int) (pivnet.UserGroup, error)) {
	fake.userGroupMutex.Lock()
	defer fake.userGroupMutex.Unlock()
	fake.UserGroupStub = stub
}

func (fake *FakePivnetClient) UserGroupArgsForCall(i int) int {
	fake.userGroupMutex.RLock()
	defer fake.userGroupMutex.RUnlock()
	argsForCall := fake.userGroupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePivnetClient) UserGroupReturns(result1 pivnet.UserGroup, result2 error) {
	fake.userGroupMutex.Lock()
	defer fake.userGroupMutex.Unlock()
	fake.UserGroupStub = nil
	fake.userGroupReturns = struct {
		result1 pivnet.UserGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) UserGroupReturnsOnCall(i int, result1 pivnet.UserGroup, result2 error) {
	fake.userGroupMutex.Lock()
	defer fake.userGroupMutex.Unlock()
	fake.UserGroupStub = nil
	if fake.userGroupReturnsOnCall == nil {
		fake.userGroupReturnsOnCall = make(map[int]struct {
			result1 pivnet.UserGroup
			result2 error
		})
	}
	fake.userGroupReturnsOnCall[i] = struct {
		result1 pivnet.UserGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) UserGroups() ([]pivnet.UserGroup, error) {
	fake.userGroupsMutex.Lock()
	ret, specificReturn := fake.userGroupsReturnsOnCall[len(fake.userGroupsArgsForCall)]
	fake.userGroupsArgsForCall = append(fake.userGroupsArgsForCall, struct {
	}{})
	fake.recordInvocation("UserGroups", []interface{}{})
	fake.userGroupsMutex.Unlock()
	if fake.UserGroupsStub != nil {
		return fake.UserGroupsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.userGroupsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) UserGroupsCallCount() int {
	fake.userGroupsMutex.RLock()
	defer fake.userGroupsMutex.RUnlock()
	return len(fake.userGroupsArgsForCall)
}

func (fake *FakePivnetClient) UserGroupsCalls(stub func() ([]pivnet.UserGroup, error)) {
	fake.userGroupsMutex.Lock()
	defer fake.userGroupsMutex.Unlock()
	fake.UserGroupsStub = stub
}

func (fake *FakePivnetClient) UserGroupsReturns(result1 []pivnet.UserGroup, result2 error) {
	fake.userGroupsMutex.Lock()
	defer fake.userGroupsMutex.Unlock()
	fake.UserGroupsStub = nil
	fake.userGroupsReturns = struct {
		result1 []pivnet.UserGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) UserGroupsReturnsOnCall(i int, result1 []pivnet.UserGroup, result2 error) {
	fake.userGroupsMutex.Lock()
	defer fake.userGroupsMutex.Unlock()
	fake.UserGroupsStub = nil
	if fake.userGroupsReturnsOnCall == nil {
		fake.userGroupsReturnsOnCall = make(map[int]struct {
			result1 []pivnet.UserGroup
			result2 error
		})
	}
	fake.userGroupsReturnsOnCall[i] = struct {
		result1 []pivnet.UserGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) UserGroupsForRelease(arg1 string, arg2 int) ([]pivnet.UserGroup, error) {
	fake.userGroupsForReleaseMutex.Lock()
	ret, specificReturn := fake.userGroupsForReleaseReturnsOnCall[len(fake.userGroupsForReleaseArgsForCall)]
	fake.userGroupsForReleaseArgsForCall = append(fake.userGroupsForReleaseArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("UserGroupsForRelease", []interface{}{arg1, arg2})
	fake.userGroupsForReleaseMutex.Unlock()
	if fake.UserGroupsForReleaseStub != nil {
		return fake.UserGroupsForReleaseStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.userGroupsForReleaseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) UserGroupsForReleaseCallCount() int {
	fake.userGroupsForReleaseMutex.RLock()
	defer fake.userGroupsForReleaseMutex.RUnlock()
	return len(fake.userGroupsForReleaseArgsForCall)
}

func (fake *FakePivnetClient) UserGroupsForReleaseCalls(stub func(string, int) ([]pivnet.UserGroup, error)) {
	fake.userGroupsForReleaseMutex.Lock()
	defer fake.userGroupsForReleaseMutex.Unlock()
	fake.UserGroupsForReleaseStub = stub
}

func (fake *FakePivnetClient) UserGroupsForReleaseArgsForCall(i int) (string, int) {
	fake.userGroupsForReleaseMutex.RLock()
	defer fake.userGroupsForReleaseMutex.RUnlock()
	argsForCall := fake.userGroupsForReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) UserGroupsForReleaseReturns(result1 []pivnet.UserGroup, result2 error) {
	fake.userGroupsForReleaseMutex.Lock()
	defer fake.userGroupsForReleaseMutex.Unlock()
	fake.UserGroupsForReleaseStub = nil
	fake.userGroupsForReleaseReturns = struct {
		result1 []pivnet.UserGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) UserGroupsForReleaseReturnsOnCall(i int, result1 []pivnet.UserGroup, result2 error) {
	fake.userGroupsForReleaseMutex.Lock()
	defer fake.userGroupsForReleaseMutex.Unlock()
	fake.UserGroupsForReleaseStub = nil
	if fake.userGroupsForReleaseReturnsOnCall == nil {
		fake.userGroupsForReleaseReturnsOnCall = make(map[int]struct {
			result1 []pivnet.UserGroup
			result2 error
		})
	}
	fake.userGroupsForReleaseReturnsOnCall[i] = struct {
		result1 []pivnet.UserGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addMemberToGroupMutex.RLock()
	defer fake.addMemberToGroupMutex.RUnlock()
	fake.addUserGroupMutex.RLock()
	defer fake.addUserGroupMutex.RUnlock()
	fake.createUserGroupMutex.RLock()
	defer fake.createUserGroupMutex.RUnlock()
	fake.deleteUserGroupMutex.RLock()
	defer fake.deleteUserGroupMutex.RUnlock()
	fake.releaseForVersionMutex.RLock()
	defer fake.releaseForVersionMutex.RUnlock()
	fake.removeMemberFromGroupMutex.RLock()
	defer fake.removeMemberFromGroupMutex.RUnlock()
	fake.removeUserGroupMutex.RLock()
	defer fake.removeUserGroupMutex.RUnlock()
	fake.updateUserGroupMutex.RLock()
	defer fake.updateUserGroupMutex.RUnlock()
	fake.userGroupMutex.RLock()
	defer fake.userGroupMutex.RUnlock()
	fake.userGroupsMutex.RLock()
	defer fake.userGroupsMutex.RUnlock()
	fake.userGroupsForReleaseMutex.RLock()
	defer fake.userGroupsForReleaseMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePivnetClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ usergroup.PivnetClient = new(FakePivnetClient)
