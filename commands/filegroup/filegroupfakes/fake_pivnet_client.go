// Code generated by counterfeiter. DO NOT EDIT.
package filegroupfakes

import (
	"sync"

	pivnet "github.com/pivotal-cf/go-pivnet/v7"
	"github.com/pivotal-cf/pivnet-cli/v3/commands/filegroup"
)

type FakePivnetClient struct {
	AddFileGroupToReleaseStub        func(string, int, int) error
	addFileGroupToReleaseMutex       sync.RWMutex
	addFileGroupToReleaseArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	addFileGroupToReleaseReturns struct {
		result1 error
	}
	addFileGroupToReleaseReturnsOnCall map[int]struct {
		result1 error
	}
	CreateFileGroupStub        func(string, string) (pivnet.FileGroup, error)
	createFileGroupMutex       sync.RWMutex
	createFileGroupArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createFileGroupReturns struct {
		result1 pivnet.FileGroup
		result2 error
	}
	createFileGroupReturnsOnCall map[int]struct {
		result1 pivnet.FileGroup
		result2 error
	}
	DeleteFileGroupStub        func(string, int) (pivnet.FileGroup, error)
	deleteFileGroupMutex       sync.RWMutex
	deleteFileGroupArgsForCall []struct {
		arg1 string
		arg2 int
	}
	deleteFileGroupReturns struct {
		result1 pivnet.FileGroup
		result2 error
	}
	deleteFileGroupReturnsOnCall map[int]struct {
		result1 pivnet.FileGroup
		result2 error
	}
	FileGroupStub        func(string, int) (pivnet.FileGroup, error)
	fileGroupMutex       sync.RWMutex
	fileGroupArgsForCall []struct {
		arg1 string
		arg2 int
	}
	fileGroupReturns struct {
		result1 pivnet.FileGroup
		result2 error
	}
	fileGroupReturnsOnCall map[int]struct {
		result1 pivnet.FileGroup
		result2 error
	}
	FileGroupsStub        func(string) ([]pivnet.FileGroup, error)
	fileGroupsMutex       sync.RWMutex
	fileGroupsArgsForCall []struct {
		arg1 string
	}
	fileGroupsReturns struct {
		result1 []pivnet.FileGroup
		result2 error
	}
	fileGroupsReturnsOnCall map[int]struct {
		result1 []pivnet.FileGroup
		result2 error
	}
	FileGroupsForReleaseStub        func(string, int) ([]pivnet.FileGroup, error)
	fileGroupsForReleaseMutex       sync.RWMutex
	fileGroupsForReleaseArgsForCall []struct {
		arg1 string
		arg2 int
	}
	fileGroupsForReleaseReturns struct {
		result1 []pivnet.FileGroup
		result2 error
	}
	fileGroupsForReleaseReturnsOnCall map[int]struct {
		result1 []pivnet.FileGroup
		result2 error
	}
	ReleaseForVersionStub        func(string, string) (pivnet.Release, error)
	releaseForVersionMutex       sync.RWMutex
	releaseForVersionArgsForCall []struct {
		arg1 string
		arg2 string
	}
	releaseForVersionReturns struct {
		result1 pivnet.Release
		result2 error
	}
	releaseForVersionReturnsOnCall map[int]struct {
		result1 pivnet.Release
		result2 error
	}
	RemoveFileGroupFromReleaseStub        func(string, int, int) error
	removeFileGroupFromReleaseMutex       sync.RWMutex
	removeFileGroupFromReleaseArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	removeFileGroupFromReleaseReturns struct {
		result1 error
	}
	removeFileGroupFromReleaseReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateFileGroupStub        func(string, pivnet.FileGroup) (pivnet.FileGroup, error)
	updateFileGroupMutex       sync.RWMutex
	updateFileGroupArgsForCall []struct {
		arg1 string
		arg2 pivnet.FileGroup
	}
	updateFileGroupReturns struct {
		result1 pivnet.FileGroup
		result2 error
	}
	updateFileGroupReturnsOnCall map[int]struct {
		result1 pivnet.FileGroup
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePivnetClient) AddFileGroupToRelease(arg1 string, arg2 int, arg3 int) error {
	fake.addFileGroupToReleaseMutex.Lock()
	ret, specificReturn := fake.addFileGroupToReleaseReturnsOnCall[len(fake.addFileGroupToReleaseArgsForCall)]
	fake.addFileGroupToReleaseArgsForCall = append(fake.addFileGroupToReleaseArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("AddFileGroupToRelease", []interface{}{arg1, arg2, arg3})
	fake.addFileGroupToReleaseMutex.Unlock()
	if fake.AddFileGroupToReleaseStub != nil {
		return fake.AddFileGroupToReleaseStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.addFileGroupToReleaseReturns
	return fakeReturns.result1
}

func (fake *FakePivnetClient) AddFileGroupToReleaseCallCount() int {
	fake.addFileGroupToReleaseMutex.RLock()
	defer fake.addFileGroupToReleaseMutex.RUnlock()
	return len(fake.addFileGroupToReleaseArgsForCall)
}

func (fake *FakePivnetClient) AddFileGroupToReleaseCalls(stub func(string, int, int) error) {
	fake.addFileGroupToReleaseMutex.Lock()
	defer fake.addFileGroupToReleaseMutex.Unlock()
	fake.AddFileGroupToReleaseStub = stub
}

func (fake *FakePivnetClient) AddFileGroupToReleaseArgsForCall(i int) (string, int, int) {
	fake.addFileGroupToReleaseMutex.RLock()
	defer fake.addFileGroupToReleaseMutex.RUnlock()
	argsForCall := fake.addFileGroupToReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePivnetClient) AddFileGroupToReleaseReturns(result1 error) {
	fake.addFileGroupToReleaseMutex.Lock()
	defer fake.addFileGroupToReleaseMutex.Unlock()
	fake.AddFileGroupToReleaseStub = nil
	fake.addFileGroupToReleaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) AddFileGroupToReleaseReturnsOnCall(i int, result1 error) {
	fake.addFileGroupToReleaseMutex.Lock()
	defer fake.addFileGroupToReleaseMutex.Unlock()
	fake.AddFileGroupToReleaseStub = nil
	if fake.addFileGroupToReleaseReturnsOnCall == nil {
		fake.addFileGroupToReleaseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addFileGroupToReleaseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) CreateFileGroup(arg1 string, arg2 string) (pivnet.FileGroup, error) {
	fake.createFileGroupMutex.Lock()
	ret, specificReturn := fake.createFileGroupReturnsOnCall[len(fake.createFileGroupArgsForCall)]
	fake.createFileGroupArgsForCall = append(fake.createFileGroupArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("CreateFileGroup", []interface{}{arg1, arg2})
	fake.createFileGroupMutex.Unlock()
	if fake.CreateFileGroupStub != nil {
		return fake.CreateFileGroupStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createFileGroupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) CreateFileGroupCallCount() int {
	fake.createFileGroupMutex.RLock()
	defer fake.createFileGroupMutex.RUnlock()
	return len(fake.createFileGroupArgsForCall)
}

func (fake *FakePivnetClient) CreateFileGroupCalls(stub func(string, string) (pivnet.FileGroup, error)) {
	fake.createFileGroupMutex.Lock()
	defer fake.createFileGroupMutex.Unlock()
	fake.CreateFileGroupStub = stub
}

func (fake *FakePivnetClient) CreateFileGroupArgsForCall(i int) (string, string) {
	fake.createFileGroupMutex.RLock()
	defer fake.createFileGroupMutex.RUnlock()
	argsForCall := fake.createFileGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) CreateFileGroupReturns(result1 pivnet.FileGroup, result2 error) {
	fake.createFileGroupMutex.Lock()
	defer fake.createFileGroupMutex.Unlock()
	fake.CreateFileGroupStub = nil
	fake.createFileGroupReturns = struct {
		result1 pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) CreateFileGroupReturnsOnCall(i int, result1 pivnet.FileGroup, result2 error) {
	fake.createFileGroupMutex.Lock()
	defer fake.createFileGroupMutex.Unlock()
	fake.CreateFileGroupStub = nil
	if fake.createFileGroupReturnsOnCall == nil {
		fake.createFileGroupReturnsOnCall = make(map[int]struct {
			result1 pivnet.FileGroup
			result2 error
		})
	}
	fake.createFileGroupReturnsOnCall[i] = struct {
		result1 pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) DeleteFileGroup(arg1 string, arg2 int) (pivnet.FileGroup, error) {
	fake.deleteFileGroupMutex.Lock()
	ret, specificReturn := fake.deleteFileGroupReturnsOnCall[len(fake.deleteFileGroupArgsForCall)]
	fake.deleteFileGroupArgsForCall = append(fake.deleteFileGroupArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("DeleteFileGroup", []interface{}{arg1, arg2})
	fake.deleteFileGroupMutex.Unlock()
	if fake.DeleteFileGroupStub != nil {
		return fake.DeleteFileGroupStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteFileGroupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) DeleteFileGroupCallCount() int {
	fake.deleteFileGroupMutex.RLock()
	defer fake.deleteFileGroupMutex.RUnlock()
	return len(fake.deleteFileGroupArgsForCall)
}

func (fake *FakePivnetClient) DeleteFileGroupCalls(stub func(string, int) (pivnet.FileGroup, error)) {
	fake.deleteFileGroupMutex.Lock()
	defer fake.deleteFileGroupMutex.Unlock()
	fake.DeleteFileGroupStub = stub
}

func (fake *FakePivnetClient) DeleteFileGroupArgsForCall(i int) (string, int) {
	fake.deleteFileGroupMutex.RLock()
	defer fake.deleteFileGroupMutex.RUnlock()
	argsForCall := fake.deleteFileGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) DeleteFileGroupReturns(result1 pivnet.FileGroup, result2 error) {
	fake.deleteFileGroupMutex.Lock()
	defer fake.deleteFileGroupMutex.Unlock()
	fake.DeleteFileGroupStub = nil
	fake.deleteFileGroupReturns = struct {
		result1 pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) DeleteFileGroupReturnsOnCall(i int, result1 pivnet.FileGroup, result2 error) {
	fake.deleteFileGroupMutex.Lock()
	defer fake.deleteFileGroupMutex.Unlock()
	fake.DeleteFileGroupStub = nil
	if fake.deleteFileGroupReturnsOnCall == nil {
		fake.deleteFileGroupReturnsOnCall = make(map[int]struct {
			result1 pivnet.FileGroup
			result2 error
		})
	}
	fake.deleteFileGroupReturnsOnCall[i] = struct {
		result1 pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) FileGroup(arg1 string, arg2 int) (pivnet.FileGroup, error) {
	fake.fileGroupMutex.Lock()
	ret, specificReturn := fake.fileGroupReturnsOnCall[len(fake.fileGroupArgsForCall)]
	fake.fileGroupArgsForCall = append(fake.fileGroupArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("FileGroup", []interface{}{arg1, arg2})
	fake.fileGroupMutex.Unlock()
	if fake.FileGroupStub != nil {
		return fake.FileGroupStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.fileGroupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) FileGroupCallCount() int {
	fake.fileGroupMutex.RLock()
	defer fake.fileGroupMutex.RUnlock()
	return len(fake.fileGroupArgsForCall)
}

func (fake *FakePivnetClient) FileGroupCalls(stub func(string, int) (pivnet.FileGroup, error)) {
	fake.fileGroupMutex.Lock()
	defer fake.fileGroupMutex.Unlock()
	fake.FileGroupStub = stub
}

func (fake *FakePivnetClient) FileGroupArgsForCall(i int) (string, int) {
	fake.fileGroupMutex.RLock()
	defer fake.fileGroupMutex.RUnlock()
	argsForCall := fake.fileGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) FileGroupReturns(result1 pivnet.FileGroup, result2 error) {
	fake.fileGroupMutex.Lock()
	defer fake.fileGroupMutex.Unlock()
	fake.FileGroupStub = nil
	fake.fileGroupReturns = struct {
		result1 pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) FileGroupReturnsOnCall(i int, result1 pivnet.FileGroup, result2 error) {
	fake.fileGroupMutex.Lock()
	defer fake.fileGroupMutex.Unlock()
	fake.FileGroupStub = nil
	if fake.fileGroupReturnsOnCall == nil {
		fake.fileGroupReturnsOnCall = make(map[int]struct {
			result1 pivnet.FileGroup
			result2 error
		})
	}
	fake.fileGroupReturnsOnCall[i] = struct {
		result1 pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) FileGroups(arg1 string) ([]pivnet.FileGroup, error) {
	fake.fileGroupsMutex.Lock()
	ret, specificReturn := fake.fileGroupsReturnsOnCall[len(fake.fileGroupsArgsForCall)]
	fake.fileGroupsArgsForCall = append(fake.fileGroupsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FileGroups", []interface{}{arg1})
	fake.fileGroupsMutex.Unlock()
	if fake.FileGroupsStub != nil {
		return fake.FileGroupsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.fileGroupsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) FileGroupsCallCount() int {
	fake.fileGroupsMutex.RLock()
	defer fake.fileGroupsMutex.RUnlock()
	return len(fake.fileGroupsArgsForCall)
}

func (fake *FakePivnetClient) FileGroupsCalls(stub func(string) ([]pivnet.FileGroup, error)) {
	fake.fileGroupsMutex.Lock()
	defer fake.fileGroupsMutex.Unlock()
	fake.FileGroupsStub = stub
}

func (fake *FakePivnetClient) FileGroupsArgsForCall(i int) string {
	fake.fileGroupsMutex.RLock()
	defer fake.fileGroupsMutex.RUnlock()
	argsForCall := fake.fileGroupsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePivnetClient) FileGroupsReturns(result1 []pivnet.FileGroup, result2 error) {
	fake.fileGroupsMutex.Lock()
	defer fake.fileGroupsMutex.Unlock()
	fake.FileGroupsStub = nil
	fake.fileGroupsReturns = struct {
		result1 []pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) FileGroupsReturnsOnCall(i int, result1 []pivnet.FileGroup, result2 error) {
	fake.fileGroupsMutex.Lock()
	defer fake.fileGroupsMutex.Unlock()
	fake.FileGroupsStub = nil
	if fake.fileGroupsReturnsOnCall == nil {
		fake.fileGroupsReturnsOnCall = make(map[int]struct {
			result1 []pivnet.FileGroup
			result2 error
		})
	}
	fake.fileGroupsReturnsOnCall[i] = struct {
		result1 []pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) FileGroupsForRelease(arg1 string, arg2 int) ([]pivnet.FileGroup, error) {
	fake.fileGroupsForReleaseMutex.Lock()
	ret, specificReturn := fake.fileGroupsForReleaseReturnsOnCall[len(fake.fileGroupsForReleaseArgsForCall)]
	fake.fileGroupsForReleaseArgsForCall = append(fake.fileGroupsForReleaseArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("FileGroupsForRelease", []interface{}{arg1, arg2})
	fake.fileGroupsForReleaseMutex.Unlock()
	if fake.FileGroupsForReleaseStub != nil {
		return fake.FileGroupsForReleaseStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.fileGroupsForReleaseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) FileGroupsForReleaseCallCount() int {
	fake.fileGroupsForReleaseMutex.RLock()
	defer fake.fileGroupsForReleaseMutex.RUnlock()
	return len(fake.fileGroupsForReleaseArgsForCall)
}

func (fake *FakePivnetClient) FileGroupsForReleaseCalls(stub func(string, int) ([]pivnet.FileGroup, error)) {
	fake.fileGroupsForReleaseMutex.Lock()
	defer fake.fileGroupsForReleaseMutex.Unlock()
	fake.FileGroupsForReleaseStub = stub
}

func (fake *FakePivnetClient) FileGroupsForReleaseArgsForCall(i int) (string, int) {
	fake.fileGroupsForReleaseMutex.RLock()
	defer fake.fileGroupsForReleaseMutex.RUnlock()
	argsForCall := fake.fileGroupsForReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) FileGroupsForReleaseReturns(result1 []pivnet.FileGroup, result2 error) {
	fake.fileGroupsForReleaseMutex.Lock()
	defer fake.fileGroupsForReleaseMutex.Unlock()
	fake.FileGroupsForReleaseStub = nil
	fake.fileGroupsForReleaseReturns = struct {
		result1 []pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) FileGroupsForReleaseReturnsOnCall(i int, result1 []pivnet.FileGroup, result2 error) {
	fake.fileGroupsForReleaseMutex.Lock()
	defer fake.fileGroupsForReleaseMutex.Unlock()
	fake.FileGroupsForReleaseStub = nil
	if fake.fileGroupsForReleaseReturnsOnCall == nil {
		fake.fileGroupsForReleaseReturnsOnCall = make(map[int]struct {
			result1 []pivnet.FileGroup
			result2 error
		})
	}
	fake.fileGroupsForReleaseReturnsOnCall[i] = struct {
		result1 []pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ReleaseForVersion(arg1 string, arg2 string) (pivnet.Release, error) {
	fake.releaseForVersionMutex.Lock()
	ret, specificReturn := fake.releaseForVersionReturnsOnCall[len(fake.releaseForVersionArgsForCall)]
	fake.releaseForVersionArgsForCall = append(fake.releaseForVersionArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ReleaseForVersion", []interface{}{arg1, arg2})
	fake.releaseForVersionMutex.Unlock()
	if fake.ReleaseForVersionStub != nil {
		return fake.ReleaseForVersionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.releaseForVersionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) ReleaseForVersionCallCount() int {
	fake.releaseForVersionMutex.RLock()
	defer fake.releaseForVersionMutex.RUnlock()
	return len(fake.releaseForVersionArgsForCall)
}

func (fake *FakePivnetClient) ReleaseForVersionCalls(stub func(string, string) (pivnet.Release, error)) {
	fake.releaseForVersionMutex.Lock()
	defer fake.releaseForVersionMutex.Unlock()
	fake.ReleaseForVersionStub = stub
}

func (fake *FakePivnetClient) ReleaseForVersionArgsForCall(i int) (string, string) {
	fake.releaseForVersionMutex.RLock()
	defer fake.releaseForVersionMutex.RUnlock()
	argsForCall := fake.releaseForVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) ReleaseForVersionReturns(result1 pivnet.Release, result2 error) {
	fake.releaseForVersionMutex.Lock()
	defer fake.releaseForVersionMutex.Unlock()
	fake.ReleaseForVersionStub = nil
	fake.releaseForVersionReturns = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ReleaseForVersionReturnsOnCall(i int, result1 pivnet.Release, result2 error) {
	fake.releaseForVersionMutex.Lock()
	defer fake.releaseForVersionMutex.Unlock()
	fake.ReleaseForVersionStub = nil
	if fake.releaseForVersionReturnsOnCall == nil {
		fake.releaseForVersionReturnsOnCall = make(map[int]struct {
			result1 pivnet.Release
			result2 error
		})
	}
	fake.releaseForVersionReturnsOnCall[i] = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) RemoveFileGroupFromRelease(arg1 string, arg2 int, arg3 int) error {
	fake.removeFileGroupFromReleaseMutex.Lock()
	ret, specificReturn := fake.removeFileGroupFromReleaseReturnsOnCall[len(fake.removeFileGroupFromReleaseArgsForCall)]
	fake.removeFileGroupFromReleaseArgsForCall = append(fake.removeFileGroupFromReleaseArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("RemoveFileGroupFromRelease", []interface{}{arg1, arg2, arg3})
	fake.removeFileGroupFromReleaseMutex.Unlock()
	if fake.RemoveFileGroupFromReleaseStub != nil {
		return fake.RemoveFileGroupFromReleaseStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeFileGroupFromReleaseReturns
	return fakeReturns.result1
}

func (fake *FakePivnetClient) RemoveFileGroupFromReleaseCallCount() int {
	fake.removeFileGroupFromReleaseMutex.RLock()
	defer fake.removeFileGroupFromReleaseMutex.RUnlock()
	return len(fake.removeFileGroupFromReleaseArgsForCall)
}

func (fake *FakePivnetClient) RemoveFileGroupFromReleaseCalls(stub func(string, int, int) error) {
	fake.removeFileGroupFromReleaseMutex.Lock()
	defer fake.removeFileGroupFromReleaseMutex.Unlock()
	fake.RemoveFileGroupFromReleaseStub = stub
}

func (fake *FakePivnetClient) RemoveFileGroupFromReleaseArgsForCall(i int) (string, int, int) {
	fake.removeFileGroupFromReleaseMutex.RLock()
	defer fake.removeFileGroupFromReleaseMutex.RUnlock()
	argsForCall := fake.removeFileGroupFromReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePivnetClient) RemoveFileGroupFromReleaseReturns(result1 error) {
	fake.removeFileGroupFromReleaseMutex.Lock()
	defer fake.removeFileGroupFromReleaseMutex.Unlock()
	fake.RemoveFileGroupFromReleaseStub = nil
	fake.removeFileGroupFromReleaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) RemoveFileGroupFromReleaseReturnsOnCall(i int, result1 error) {
	fake.removeFileGroupFromReleaseMutex.Lock()
	defer fake.removeFileGroupFromReleaseMutex.Unlock()
	fake.RemoveFileGroupFromReleaseStub = nil
	if fake.removeFileGroupFromReleaseReturnsOnCall == nil {
		fake.removeFileGroupFromReleaseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeFileGroupFromReleaseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) UpdateFileGroup(arg1 string, arg2 pivnet.FileGroup) (pivnet.FileGroup, error) {
	fake.updateFileGroupMutex.Lock()
	ret, specificReturn := fake.updateFileGroupReturnsOnCall[len(fake.updateFileGroupArgsForCall)]
	fake.updateFileGroupArgsForCall = append(fake.updateFileGroupArgsForCall, struct {
		arg1 string
		arg2 pivnet.FileGroup
	}{arg1, arg2})
	fake.recordInvocation("UpdateFileGroup", []interface{}{arg1, arg2})
	fake.updateFileGroupMutex.Unlock()
	if fake.UpdateFileGroupStub != nil {
		return fake.UpdateFileGroupStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateFileGroupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) UpdateFileGroupCallCount() int {
	fake.updateFileGroupMutex.RLock()
	defer fake.updateFileGroupMutex.RUnlock()
	return len(fake.updateFileGroupArgsForCall)
}

func (fake *FakePivnetClient) UpdateFileGroupCalls(stub func(string, pivnet.FileGroup) (pivnet.FileGroup, error)) {
	fake.updateFileGroupMutex.Lock()
	defer fake.updateFileGroupMutex.Unlock()
	fake.UpdateFileGroupStub = stub
}

func (fake *FakePivnetClient) UpdateFileGroupArgsForCall(i int) (string, pivnet.FileGroup) {
	fake.updateFileGroupMutex.RLock()
	defer fake.updateFileGroupMutex.RUnlock()
	argsForCall := fake.updateFileGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) UpdateFileGroupReturns(result1 pivnet.FileGroup, result2 error) {
	fake.updateFileGroupMutex.Lock()
	defer fake.updateFileGroupMutex.Unlock()
	fake.UpdateFileGroupStub = nil
	fake.updateFileGroupReturns = struct {
		result1 pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) UpdateFileGroupReturnsOnCall(i int, result1 pivnet.FileGroup, result2 error) {
	fake.updateFileGroupMutex.Lock()
	defer fake.updateFileGroupMutex.Unlock()
	fake.UpdateFileGroupStub = nil
	if fake.updateFileGroupReturnsOnCall == nil {
		fake.updateFileGroupReturnsOnCall = make(map[int]struct {
			result1 pivnet.FileGroup
			result2 error
		})
	}
	fake.updateFileGroupReturnsOnCall[i] = struct {
		result1 pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addFileGroupToReleaseMutex.RLock()
	defer fake.addFileGroupToReleaseMutex.RUnlock()
	fake.createFileGroupMutex.RLock()
	defer fake.createFileGroupMutex.RUnlock()
	fake.deleteFileGroupMutex.RLock()
	defer fake.deleteFileGroupMutex.RUnlock()
	fake.fileGroupMutex.RLock()
	defer fake.fileGroupMutex.RUnlock()
	fake.fileGroupsMutex.RLock()
	defer fake.fileGroupsMutex.RUnlock()
	fake.fileGroupsForReleaseMutex.RLock()
	defer fake.fileGroupsForReleaseMutex.RUnlock()
	fake.releaseForVersionMutex.RLock()
	defer fake.releaseForVersionMutex.RUnlock()
	fake.removeFileGroupFromReleaseMutex.RLock()
	defer fake.removeFileGroupFromReleaseMutex.RUnlock()
	fake.updateFileGroupMutex.RLock()
	defer fake.updateFileGroupMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePivnetClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ filegroup.PivnetClient = new(FakePivnetClient)
