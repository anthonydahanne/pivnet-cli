// Code generated by counterfeiter. DO NOT EDIT.
package productfilefakes

import (
	"io"
	"sync"

	pivnet "github.com/pivotal-cf/go-pivnet/v7"
	"github.com/pivotal-cf/go-pivnet/v7/download"
	"github.com/pivotal-cf/pivnet-cli/v3/commands/productfile"
)

type FakePivnetClient struct {
	AcceptEULAStub        func(string, int) error
	acceptEULAMutex       sync.RWMutex
	acceptEULAArgsForCall []struct {
		arg1 string
		arg2 int
	}
	acceptEULAReturns struct {
		result1 error
	}
	acceptEULAReturnsOnCall map[int]struct {
		result1 error
	}
	AddProductFileToFileGroupStub        func(string, int, int) error
	addProductFileToFileGroupMutex       sync.RWMutex
	addProductFileToFileGroupArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	addProductFileToFileGroupReturns struct {
		result1 error
	}
	addProductFileToFileGroupReturnsOnCall map[int]struct {
		result1 error
	}
	AddProductFileToReleaseStub        func(string, int, int) error
	addProductFileToReleaseMutex       sync.RWMutex
	addProductFileToReleaseArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	addProductFileToReleaseReturns struct {
		result1 error
	}
	addProductFileToReleaseReturnsOnCall map[int]struct {
		result1 error
	}
	CreateProductFileStub        func(pivnet.CreateProductFileConfig) (pivnet.ProductFile, error)
	createProductFileMutex       sync.RWMutex
	createProductFileArgsForCall []struct {
		arg1 pivnet.CreateProductFileConfig
	}
	createProductFileReturns struct {
		result1 pivnet.ProductFile
		result2 error
	}
	createProductFileReturnsOnCall map[int]struct {
		result1 pivnet.ProductFile
		result2 error
	}
	DeleteProductFileStub        func(string, int) (pivnet.ProductFile, error)
	deleteProductFileMutex       sync.RWMutex
	deleteProductFileArgsForCall []struct {
		arg1 string
		arg2 int
	}
	deleteProductFileReturns struct {
		result1 pivnet.ProductFile
		result2 error
	}
	deleteProductFileReturnsOnCall map[int]struct {
		result1 pivnet.ProductFile
		result2 error
	}
	DownloadProductFileStub        func(*download.FileInfo, string, int, int, io.Writer) error
	downloadProductFileMutex       sync.RWMutex
	downloadProductFileArgsForCall []struct {
		arg1 *download.FileInfo
		arg2 string
		arg3 int
		arg4 int
		arg5 io.Writer
	}
	downloadProductFileReturns struct {
		result1 error
	}
	downloadProductFileReturnsOnCall map[int]struct {
		result1 error
	}
	ProductFileStub        func(string, int) (pivnet.ProductFile, error)
	productFileMutex       sync.RWMutex
	productFileArgsForCall []struct {
		arg1 string
		arg2 int
	}
	productFileReturns struct {
		result1 pivnet.ProductFile
		result2 error
	}
	productFileReturnsOnCall map[int]struct {
		result1 pivnet.ProductFile
		result2 error
	}
	ProductFileForReleaseStub        func(string, int, int) (pivnet.ProductFile, error)
	productFileForReleaseMutex       sync.RWMutex
	productFileForReleaseArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	productFileForReleaseReturns struct {
		result1 pivnet.ProductFile
		result2 error
	}
	productFileForReleaseReturnsOnCall map[int]struct {
		result1 pivnet.ProductFile
		result2 error
	}
	ProductFilesStub        func(string) ([]pivnet.ProductFile, error)
	productFilesMutex       sync.RWMutex
	productFilesArgsForCall []struct {
		arg1 string
	}
	productFilesReturns struct {
		result1 []pivnet.ProductFile
		result2 error
	}
	productFilesReturnsOnCall map[int]struct {
		result1 []pivnet.ProductFile
		result2 error
	}
	ProductFilesForReleaseStub        func(string, int) ([]pivnet.ProductFile, error)
	productFilesForReleaseMutex       sync.RWMutex
	productFilesForReleaseArgsForCall []struct {
		arg1 string
		arg2 int
	}
	productFilesForReleaseReturns struct {
		result1 []pivnet.ProductFile
		result2 error
	}
	productFilesForReleaseReturnsOnCall map[int]struct {
		result1 []pivnet.ProductFile
		result2 error
	}
	ReleaseForVersionStub        func(string, string) (pivnet.Release, error)
	releaseForVersionMutex       sync.RWMutex
	releaseForVersionArgsForCall []struct {
		arg1 string
		arg2 string
	}
	releaseForVersionReturns struct {
		result1 pivnet.Release
		result2 error
	}
	releaseForVersionReturnsOnCall map[int]struct {
		result1 pivnet.Release
		result2 error
	}
	RemoveProductFileFromFileGroupStub        func(string, int, int) error
	removeProductFileFromFileGroupMutex       sync.RWMutex
	removeProductFileFromFileGroupArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	removeProductFileFromFileGroupReturns struct {
		result1 error
	}
	removeProductFileFromFileGroupReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveProductFileFromReleaseStub        func(string, int, int) error
	removeProductFileFromReleaseMutex       sync.RWMutex
	removeProductFileFromReleaseArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	removeProductFileFromReleaseReturns struct {
		result1 error
	}
	removeProductFileFromReleaseReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateProductFileStub        func(string, pivnet.ProductFile) (pivnet.ProductFile, error)
	updateProductFileMutex       sync.RWMutex
	updateProductFileArgsForCall []struct {
		arg1 string
		arg2 pivnet.ProductFile
	}
	updateProductFileReturns struct {
		result1 pivnet.ProductFile
		result2 error
	}
	updateProductFileReturnsOnCall map[int]struct {
		result1 pivnet.ProductFile
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePivnetClient) AcceptEULA(arg1 string, arg2 int) error {
	fake.acceptEULAMutex.Lock()
	ret, specificReturn := fake.acceptEULAReturnsOnCall[len(fake.acceptEULAArgsForCall)]
	fake.acceptEULAArgsForCall = append(fake.acceptEULAArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("AcceptEULA", []interface{}{arg1, arg2})
	fake.acceptEULAMutex.Unlock()
	if fake.AcceptEULAStub != nil {
		return fake.AcceptEULAStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.acceptEULAReturns
	return fakeReturns.result1
}

func (fake *FakePivnetClient) AcceptEULACallCount() int {
	fake.acceptEULAMutex.RLock()
	defer fake.acceptEULAMutex.RUnlock()
	return len(fake.acceptEULAArgsForCall)
}

func (fake *FakePivnetClient) AcceptEULACalls(stub func(string, int) error) {
	fake.acceptEULAMutex.Lock()
	defer fake.acceptEULAMutex.Unlock()
	fake.AcceptEULAStub = stub
}

func (fake *FakePivnetClient) AcceptEULAArgsForCall(i int) (string, int) {
	fake.acceptEULAMutex.RLock()
	defer fake.acceptEULAMutex.RUnlock()
	argsForCall := fake.acceptEULAArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) AcceptEULAReturns(result1 error) {
	fake.acceptEULAMutex.Lock()
	defer fake.acceptEULAMutex.Unlock()
	fake.AcceptEULAStub = nil
	fake.acceptEULAReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) AcceptEULAReturnsOnCall(i int, result1 error) {
	fake.acceptEULAMutex.Lock()
	defer fake.acceptEULAMutex.Unlock()
	fake.AcceptEULAStub = nil
	if fake.acceptEULAReturnsOnCall == nil {
		fake.acceptEULAReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.acceptEULAReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) AddProductFileToFileGroup(arg1 string, arg2 int, arg3 int) error {
	fake.addProductFileToFileGroupMutex.Lock()
	ret, specificReturn := fake.addProductFileToFileGroupReturnsOnCall[len(fake.addProductFileToFileGroupArgsForCall)]
	fake.addProductFileToFileGroupArgsForCall = append(fake.addProductFileToFileGroupArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("AddProductFileToFileGroup", []interface{}{arg1, arg2, arg3})
	fake.addProductFileToFileGroupMutex.Unlock()
	if fake.AddProductFileToFileGroupStub != nil {
		return fake.AddProductFileToFileGroupStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.addProductFileToFileGroupReturns
	return fakeReturns.result1
}

func (fake *FakePivnetClient) AddProductFileToFileGroupCallCount() int {
	fake.addProductFileToFileGroupMutex.RLock()
	defer fake.addProductFileToFileGroupMutex.RUnlock()
	return len(fake.addProductFileToFileGroupArgsForCall)
}

func (fake *FakePivnetClient) AddProductFileToFileGroupCalls(stub func(string, int, int) error) {
	fake.addProductFileToFileGroupMutex.Lock()
	defer fake.addProductFileToFileGroupMutex.Unlock()
	fake.AddProductFileToFileGroupStub = stub
}

func (fake *FakePivnetClient) AddProductFileToFileGroupArgsForCall(i int) (string, int, int) {
	fake.addProductFileToFileGroupMutex.RLock()
	defer fake.addProductFileToFileGroupMutex.RUnlock()
	argsForCall := fake.addProductFileToFileGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePivnetClient) AddProductFileToFileGroupReturns(result1 error) {
	fake.addProductFileToFileGroupMutex.Lock()
	defer fake.addProductFileToFileGroupMutex.Unlock()
	fake.AddProductFileToFileGroupStub = nil
	fake.addProductFileToFileGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) AddProductFileToFileGroupReturnsOnCall(i int, result1 error) {
	fake.addProductFileToFileGroupMutex.Lock()
	defer fake.addProductFileToFileGroupMutex.Unlock()
	fake.AddProductFileToFileGroupStub = nil
	if fake.addProductFileToFileGroupReturnsOnCall == nil {
		fake.addProductFileToFileGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addProductFileToFileGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) AddProductFileToRelease(arg1 string, arg2 int, arg3 int) error {
	fake.addProductFileToReleaseMutex.Lock()
	ret, specificReturn := fake.addProductFileToReleaseReturnsOnCall[len(fake.addProductFileToReleaseArgsForCall)]
	fake.addProductFileToReleaseArgsForCall = append(fake.addProductFileToReleaseArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("AddProductFileToRelease", []interface{}{arg1, arg2, arg3})
	fake.addProductFileToReleaseMutex.Unlock()
	if fake.AddProductFileToReleaseStub != nil {
		return fake.AddProductFileToReleaseStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.addProductFileToReleaseReturns
	return fakeReturns.result1
}

func (fake *FakePivnetClient) AddProductFileToReleaseCallCount() int {
	fake.addProductFileToReleaseMutex.RLock()
	defer fake.addProductFileToReleaseMutex.RUnlock()
	return len(fake.addProductFileToReleaseArgsForCall)
}

func (fake *FakePivnetClient) AddProductFileToReleaseCalls(stub func(string, int, int) error) {
	fake.addProductFileToReleaseMutex.Lock()
	defer fake.addProductFileToReleaseMutex.Unlock()
	fake.AddProductFileToReleaseStub = stub
}

func (fake *FakePivnetClient) AddProductFileToReleaseArgsForCall(i int) (string, int, int) {
	fake.addProductFileToReleaseMutex.RLock()
	defer fake.addProductFileToReleaseMutex.RUnlock()
	argsForCall := fake.addProductFileToReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePivnetClient) AddProductFileToReleaseReturns(result1 error) {
	fake.addProductFileToReleaseMutex.Lock()
	defer fake.addProductFileToReleaseMutex.Unlock()
	fake.AddProductFileToReleaseStub = nil
	fake.addProductFileToReleaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) AddProductFileToReleaseReturnsOnCall(i int, result1 error) {
	fake.addProductFileToReleaseMutex.Lock()
	defer fake.addProductFileToReleaseMutex.Unlock()
	fake.AddProductFileToReleaseStub = nil
	if fake.addProductFileToReleaseReturnsOnCall == nil {
		fake.addProductFileToReleaseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addProductFileToReleaseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) CreateProductFile(arg1 pivnet.CreateProductFileConfig) (pivnet.ProductFile, error) {
	fake.createProductFileMutex.Lock()
	ret, specificReturn := fake.createProductFileReturnsOnCall[len(fake.createProductFileArgsForCall)]
	fake.createProductFileArgsForCall = append(fake.createProductFileArgsForCall, struct {
		arg1 pivnet.CreateProductFileConfig
	}{arg1})
	fake.recordInvocation("CreateProductFile", []interface{}{arg1})
	fake.createProductFileMutex.Unlock()
	if fake.CreateProductFileStub != nil {
		return fake.CreateProductFileStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createProductFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) CreateProductFileCallCount() int {
	fake.createProductFileMutex.RLock()
	defer fake.createProductFileMutex.RUnlock()
	return len(fake.createProductFileArgsForCall)
}

func (fake *FakePivnetClient) CreateProductFileCalls(stub func(pivnet.CreateProductFileConfig) (pivnet.ProductFile, error)) {
	fake.createProductFileMutex.Lock()
	defer fake.createProductFileMutex.Unlock()
	fake.CreateProductFileStub = stub
}

func (fake *FakePivnetClient) CreateProductFileArgsForCall(i int) pivnet.CreateProductFileConfig {
	fake.createProductFileMutex.RLock()
	defer fake.createProductFileMutex.RUnlock()
	argsForCall := fake.createProductFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePivnetClient) CreateProductFileReturns(result1 pivnet.ProductFile, result2 error) {
	fake.createProductFileMutex.Lock()
	defer fake.createProductFileMutex.Unlock()
	fake.CreateProductFileStub = nil
	fake.createProductFileReturns = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) CreateProductFileReturnsOnCall(i int, result1 pivnet.ProductFile, result2 error) {
	fake.createProductFileMutex.Lock()
	defer fake.createProductFileMutex.Unlock()
	fake.CreateProductFileStub = nil
	if fake.createProductFileReturnsOnCall == nil {
		fake.createProductFileReturnsOnCall = make(map[int]struct {
			result1 pivnet.ProductFile
			result2 error
		})
	}
	fake.createProductFileReturnsOnCall[i] = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) DeleteProductFile(arg1 string, arg2 int) (pivnet.ProductFile, error) {
	fake.deleteProductFileMutex.Lock()
	ret, specificReturn := fake.deleteProductFileReturnsOnCall[len(fake.deleteProductFileArgsForCall)]
	fake.deleteProductFileArgsForCall = append(fake.deleteProductFileArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("DeleteProductFile", []interface{}{arg1, arg2})
	fake.deleteProductFileMutex.Unlock()
	if fake.DeleteProductFileStub != nil {
		return fake.DeleteProductFileStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteProductFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) DeleteProductFileCallCount() int {
	fake.deleteProductFileMutex.RLock()
	defer fake.deleteProductFileMutex.RUnlock()
	return len(fake.deleteProductFileArgsForCall)
}

func (fake *FakePivnetClient) DeleteProductFileCalls(stub func(string, int) (pivnet.ProductFile, error)) {
	fake.deleteProductFileMutex.Lock()
	defer fake.deleteProductFileMutex.Unlock()
	fake.DeleteProductFileStub = stub
}

func (fake *FakePivnetClient) DeleteProductFileArgsForCall(i int) (string, int) {
	fake.deleteProductFileMutex.RLock()
	defer fake.deleteProductFileMutex.RUnlock()
	argsForCall := fake.deleteProductFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) DeleteProductFileReturns(result1 pivnet.ProductFile, result2 error) {
	fake.deleteProductFileMutex.Lock()
	defer fake.deleteProductFileMutex.Unlock()
	fake.DeleteProductFileStub = nil
	fake.deleteProductFileReturns = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) DeleteProductFileReturnsOnCall(i int, result1 pivnet.ProductFile, result2 error) {
	fake.deleteProductFileMutex.Lock()
	defer fake.deleteProductFileMutex.Unlock()
	fake.DeleteProductFileStub = nil
	if fake.deleteProductFileReturnsOnCall == nil {
		fake.deleteProductFileReturnsOnCall = make(map[int]struct {
			result1 pivnet.ProductFile
			result2 error
		})
	}
	fake.deleteProductFileReturnsOnCall[i] = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) DownloadProductFile(arg1 *download.FileInfo, arg2 string, arg3 int, arg4 int, arg5 io.Writer) error {
	fake.downloadProductFileMutex.Lock()
	ret, specificReturn := fake.downloadProductFileReturnsOnCall[len(fake.downloadProductFileArgsForCall)]
	fake.downloadProductFileArgsForCall = append(fake.downloadProductFileArgsForCall, struct {
		arg1 *download.FileInfo
		arg2 string
		arg3 int
		arg4 int
		arg5 io.Writer
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("DownloadProductFile", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.downloadProductFileMutex.Unlock()
	if fake.DownloadProductFileStub != nil {
		return fake.DownloadProductFileStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.downloadProductFileReturns
	return fakeReturns.result1
}

func (fake *FakePivnetClient) DownloadProductFileCallCount() int {
	fake.downloadProductFileMutex.RLock()
	defer fake.downloadProductFileMutex.RUnlock()
	return len(fake.downloadProductFileArgsForCall)
}

func (fake *FakePivnetClient) DownloadProductFileCalls(stub func(*download.FileInfo, string, int, int, io.Writer) error) {
	fake.downloadProductFileMutex.Lock()
	defer fake.downloadProductFileMutex.Unlock()
	fake.DownloadProductFileStub = stub
}

func (fake *FakePivnetClient) DownloadProductFileArgsForCall(i int) (*download.FileInfo, string, int, int, io.Writer) {
	fake.downloadProductFileMutex.RLock()
	defer fake.downloadProductFileMutex.RUnlock()
	argsForCall := fake.downloadProductFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePivnetClient) DownloadProductFileReturns(result1 error) {
	fake.downloadProductFileMutex.Lock()
	defer fake.downloadProductFileMutex.Unlock()
	fake.DownloadProductFileStub = nil
	fake.downloadProductFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) DownloadProductFileReturnsOnCall(i int, result1 error) {
	fake.downloadProductFileMutex.Lock()
	defer fake.downloadProductFileMutex.Unlock()
	fake.DownloadProductFileStub = nil
	if fake.downloadProductFileReturnsOnCall == nil {
		fake.downloadProductFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.downloadProductFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) ProductFile(arg1 string, arg2 int) (pivnet.ProductFile, error) {
	fake.productFileMutex.Lock()
	ret, specificReturn := fake.productFileReturnsOnCall[len(fake.productFileArgsForCall)]
	fake.productFileArgsForCall = append(fake.productFileArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("ProductFile", []interface{}{arg1, arg2})
	fake.productFileMutex.Unlock()
	if fake.ProductFileStub != nil {
		return fake.ProductFileStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.productFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) ProductFileCallCount() int {
	fake.productFileMutex.RLock()
	defer fake.productFileMutex.RUnlock()
	return len(fake.productFileArgsForCall)
}

func (fake *FakePivnetClient) ProductFileCalls(stub func(string, int) (pivnet.ProductFile, error)) {
	fake.productFileMutex.Lock()
	defer fake.productFileMutex.Unlock()
	fake.ProductFileStub = stub
}

func (fake *FakePivnetClient) ProductFileArgsForCall(i int) (string, int) {
	fake.productFileMutex.RLock()
	defer fake.productFileMutex.RUnlock()
	argsForCall := fake.productFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) ProductFileReturns(result1 pivnet.ProductFile, result2 error) {
	fake.productFileMutex.Lock()
	defer fake.productFileMutex.Unlock()
	fake.ProductFileStub = nil
	fake.productFileReturns = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ProductFileReturnsOnCall(i int, result1 pivnet.ProductFile, result2 error) {
	fake.productFileMutex.Lock()
	defer fake.productFileMutex.Unlock()
	fake.ProductFileStub = nil
	if fake.productFileReturnsOnCall == nil {
		fake.productFileReturnsOnCall = make(map[int]struct {
			result1 pivnet.ProductFile
			result2 error
		})
	}
	fake.productFileReturnsOnCall[i] = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ProductFileForRelease(arg1 string, arg2 int, arg3 int) (pivnet.ProductFile, error) {
	fake.productFileForReleaseMutex.Lock()
	ret, specificReturn := fake.productFileForReleaseReturnsOnCall[len(fake.productFileForReleaseArgsForCall)]
	fake.productFileForReleaseArgsForCall = append(fake.productFileForReleaseArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("ProductFileForRelease", []interface{}{arg1, arg2, arg3})
	fake.productFileForReleaseMutex.Unlock()
	if fake.ProductFileForReleaseStub != nil {
		return fake.ProductFileForReleaseStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.productFileForReleaseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) ProductFileForReleaseCallCount() int {
	fake.productFileForReleaseMutex.RLock()
	defer fake.productFileForReleaseMutex.RUnlock()
	return len(fake.productFileForReleaseArgsForCall)
}

func (fake *FakePivnetClient) ProductFileForReleaseCalls(stub func(string, int, int) (pivnet.ProductFile, error)) {
	fake.productFileForReleaseMutex.Lock()
	defer fake.productFileForReleaseMutex.Unlock()
	fake.ProductFileForReleaseStub = stub
}

func (fake *FakePivnetClient) ProductFileForReleaseArgsForCall(i int) (string, int, int) {
	fake.productFileForReleaseMutex.RLock()
	defer fake.productFileForReleaseMutex.RUnlock()
	argsForCall := fake.productFileForReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePivnetClient) ProductFileForReleaseReturns(result1 pivnet.ProductFile, result2 error) {
	fake.productFileForReleaseMutex.Lock()
	defer fake.productFileForReleaseMutex.Unlock()
	fake.ProductFileForReleaseStub = nil
	fake.productFileForReleaseReturns = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ProductFileForReleaseReturnsOnCall(i int, result1 pivnet.ProductFile, result2 error) {
	fake.productFileForReleaseMutex.Lock()
	defer fake.productFileForReleaseMutex.Unlock()
	fake.ProductFileForReleaseStub = nil
	if fake.productFileForReleaseReturnsOnCall == nil {
		fake.productFileForReleaseReturnsOnCall = make(map[int]struct {
			result1 pivnet.ProductFile
			result2 error
		})
	}
	fake.productFileForReleaseReturnsOnCall[i] = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ProductFiles(arg1 string) ([]pivnet.ProductFile, error) {
	fake.productFilesMutex.Lock()
	ret, specificReturn := fake.productFilesReturnsOnCall[len(fake.productFilesArgsForCall)]
	fake.productFilesArgsForCall = append(fake.productFilesArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ProductFiles", []interface{}{arg1})
	fake.productFilesMutex.Unlock()
	if fake.ProductFilesStub != nil {
		return fake.ProductFilesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.productFilesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) ProductFilesCallCount() int {
	fake.productFilesMutex.RLock()
	defer fake.productFilesMutex.RUnlock()
	return len(fake.productFilesArgsForCall)
}

func (fake *FakePivnetClient) ProductFilesCalls(stub func(string) ([]pivnet.ProductFile, error)) {
	fake.productFilesMutex.Lock()
	defer fake.productFilesMutex.Unlock()
	fake.ProductFilesStub = stub
}

func (fake *FakePivnetClient) ProductFilesArgsForCall(i int) string {
	fake.productFilesMutex.RLock()
	defer fake.productFilesMutex.RUnlock()
	argsForCall := fake.productFilesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePivnetClient) ProductFilesReturns(result1 []pivnet.ProductFile, result2 error) {
	fake.productFilesMutex.Lock()
	defer fake.productFilesMutex.Unlock()
	fake.ProductFilesStub = nil
	fake.productFilesReturns = struct {
		result1 []pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ProductFilesReturnsOnCall(i int, result1 []pivnet.ProductFile, result2 error) {
	fake.productFilesMutex.Lock()
	defer fake.productFilesMutex.Unlock()
	fake.ProductFilesStub = nil
	if fake.productFilesReturnsOnCall == nil {
		fake.productFilesReturnsOnCall = make(map[int]struct {
			result1 []pivnet.ProductFile
			result2 error
		})
	}
	fake.productFilesReturnsOnCall[i] = struct {
		result1 []pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ProductFilesForRelease(arg1 string, arg2 int) ([]pivnet.ProductFile, error) {
	fake.productFilesForReleaseMutex.Lock()
	ret, specificReturn := fake.productFilesForReleaseReturnsOnCall[len(fake.productFilesForReleaseArgsForCall)]
	fake.productFilesForReleaseArgsForCall = append(fake.productFilesForReleaseArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("ProductFilesForRelease", []interface{}{arg1, arg2})
	fake.productFilesForReleaseMutex.Unlock()
	if fake.ProductFilesForReleaseStub != nil {
		return fake.ProductFilesForReleaseStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.productFilesForReleaseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) ProductFilesForReleaseCallCount() int {
	fake.productFilesForReleaseMutex.RLock()
	defer fake.productFilesForReleaseMutex.RUnlock()
	return len(fake.productFilesForReleaseArgsForCall)
}

func (fake *FakePivnetClient) ProductFilesForReleaseCalls(stub func(string, int) ([]pivnet.ProductFile, error)) {
	fake.productFilesForReleaseMutex.Lock()
	defer fake.productFilesForReleaseMutex.Unlock()
	fake.ProductFilesForReleaseStub = stub
}

func (fake *FakePivnetClient) ProductFilesForReleaseArgsForCall(i int) (string, int) {
	fake.productFilesForReleaseMutex.RLock()
	defer fake.productFilesForReleaseMutex.RUnlock()
	argsForCall := fake.productFilesForReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) ProductFilesForReleaseReturns(result1 []pivnet.ProductFile, result2 error) {
	fake.productFilesForReleaseMutex.Lock()
	defer fake.productFilesForReleaseMutex.Unlock()
	fake.ProductFilesForReleaseStub = nil
	fake.productFilesForReleaseReturns = struct {
		result1 []pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ProductFilesForReleaseReturnsOnCall(i int, result1 []pivnet.ProductFile, result2 error) {
	fake.productFilesForReleaseMutex.Lock()
	defer fake.productFilesForReleaseMutex.Unlock()
	fake.ProductFilesForReleaseStub = nil
	if fake.productFilesForReleaseReturnsOnCall == nil {
		fake.productFilesForReleaseReturnsOnCall = make(map[int]struct {
			result1 []pivnet.ProductFile
			result2 error
		})
	}
	fake.productFilesForReleaseReturnsOnCall[i] = struct {
		result1 []pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ReleaseForVersion(arg1 string, arg2 string) (pivnet.Release, error) {
	fake.releaseForVersionMutex.Lock()
	ret, specificReturn := fake.releaseForVersionReturnsOnCall[len(fake.releaseForVersionArgsForCall)]
	fake.releaseForVersionArgsForCall = append(fake.releaseForVersionArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ReleaseForVersion", []interface{}{arg1, arg2})
	fake.releaseForVersionMutex.Unlock()
	if fake.ReleaseForVersionStub != nil {
		return fake.ReleaseForVersionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.releaseForVersionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) ReleaseForVersionCallCount() int {
	fake.releaseForVersionMutex.RLock()
	defer fake.releaseForVersionMutex.RUnlock()
	return len(fake.releaseForVersionArgsForCall)
}

func (fake *FakePivnetClient) ReleaseForVersionCalls(stub func(string, string) (pivnet.Release, error)) {
	fake.releaseForVersionMutex.Lock()
	defer fake.releaseForVersionMutex.Unlock()
	fake.ReleaseForVersionStub = stub
}

func (fake *FakePivnetClient) ReleaseForVersionArgsForCall(i int) (string, string) {
	fake.releaseForVersionMutex.RLock()
	defer fake.releaseForVersionMutex.RUnlock()
	argsForCall := fake.releaseForVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) ReleaseForVersionReturns(result1 pivnet.Release, result2 error) {
	fake.releaseForVersionMutex.Lock()
	defer fake.releaseForVersionMutex.Unlock()
	fake.ReleaseForVersionStub = nil
	fake.releaseForVersionReturns = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ReleaseForVersionReturnsOnCall(i int, result1 pivnet.Release, result2 error) {
	fake.releaseForVersionMutex.Lock()
	defer fake.releaseForVersionMutex.Unlock()
	fake.ReleaseForVersionStub = nil
	if fake.releaseForVersionReturnsOnCall == nil {
		fake.releaseForVersionReturnsOnCall = make(map[int]struct {
			result1 pivnet.Release
			result2 error
		})
	}
	fake.releaseForVersionReturnsOnCall[i] = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) RemoveProductFileFromFileGroup(arg1 string, arg2 int, arg3 int) error {
	fake.removeProductFileFromFileGroupMutex.Lock()
	ret, specificReturn := fake.removeProductFileFromFileGroupReturnsOnCall[len(fake.removeProductFileFromFileGroupArgsForCall)]
	fake.removeProductFileFromFileGroupArgsForCall = append(fake.removeProductFileFromFileGroupArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("RemoveProductFileFromFileGroup", []interface{}{arg1, arg2, arg3})
	fake.removeProductFileFromFileGroupMutex.Unlock()
	if fake.RemoveProductFileFromFileGroupStub != nil {
		return fake.RemoveProductFileFromFileGroupStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeProductFileFromFileGroupReturns
	return fakeReturns.result1
}

func (fake *FakePivnetClient) RemoveProductFileFromFileGroupCallCount() int {
	fake.removeProductFileFromFileGroupMutex.RLock()
	defer fake.removeProductFileFromFileGroupMutex.RUnlock()
	return len(fake.removeProductFileFromFileGroupArgsForCall)
}

func (fake *FakePivnetClient) RemoveProductFileFromFileGroupCalls(stub func(string, int, int) error) {
	fake.removeProductFileFromFileGroupMutex.Lock()
	defer fake.removeProductFileFromFileGroupMutex.Unlock()
	fake.RemoveProductFileFromFileGroupStub = stub
}

func (fake *FakePivnetClient) RemoveProductFileFromFileGroupArgsForCall(i int) (string, int, int) {
	fake.removeProductFileFromFileGroupMutex.RLock()
	defer fake.removeProductFileFromFileGroupMutex.RUnlock()
	argsForCall := fake.removeProductFileFromFileGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePivnetClient) RemoveProductFileFromFileGroupReturns(result1 error) {
	fake.removeProductFileFromFileGroupMutex.Lock()
	defer fake.removeProductFileFromFileGroupMutex.Unlock()
	fake.RemoveProductFileFromFileGroupStub = nil
	fake.removeProductFileFromFileGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) RemoveProductFileFromFileGroupReturnsOnCall(i int, result1 error) {
	fake.removeProductFileFromFileGroupMutex.Lock()
	defer fake.removeProductFileFromFileGroupMutex.Unlock()
	fake.RemoveProductFileFromFileGroupStub = nil
	if fake.removeProductFileFromFileGroupReturnsOnCall == nil {
		fake.removeProductFileFromFileGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeProductFileFromFileGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) RemoveProductFileFromRelease(arg1 string, arg2 int, arg3 int) error {
	fake.removeProductFileFromReleaseMutex.Lock()
	ret, specificReturn := fake.removeProductFileFromReleaseReturnsOnCall[len(fake.removeProductFileFromReleaseArgsForCall)]
	fake.removeProductFileFromReleaseArgsForCall = append(fake.removeProductFileFromReleaseArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("RemoveProductFileFromRelease", []interface{}{arg1, arg2, arg3})
	fake.removeProductFileFromReleaseMutex.Unlock()
	if fake.RemoveProductFileFromReleaseStub != nil {
		return fake.RemoveProductFileFromReleaseStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeProductFileFromReleaseReturns
	return fakeReturns.result1
}

func (fake *FakePivnetClient) RemoveProductFileFromReleaseCallCount() int {
	fake.removeProductFileFromReleaseMutex.RLock()
	defer fake.removeProductFileFromReleaseMutex.RUnlock()
	return len(fake.removeProductFileFromReleaseArgsForCall)
}

func (fake *FakePivnetClient) RemoveProductFileFromReleaseCalls(stub func(string, int, int) error) {
	fake.removeProductFileFromReleaseMutex.Lock()
	defer fake.removeProductFileFromReleaseMutex.Unlock()
	fake.RemoveProductFileFromReleaseStub = stub
}

func (fake *FakePivnetClient) RemoveProductFileFromReleaseArgsForCall(i int) (string, int, int) {
	fake.removeProductFileFromReleaseMutex.RLock()
	defer fake.removeProductFileFromReleaseMutex.RUnlock()
	argsForCall := fake.removeProductFileFromReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePivnetClient) RemoveProductFileFromReleaseReturns(result1 error) {
	fake.removeProductFileFromReleaseMutex.Lock()
	defer fake.removeProductFileFromReleaseMutex.Unlock()
	fake.RemoveProductFileFromReleaseStub = nil
	fake.removeProductFileFromReleaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) RemoveProductFileFromReleaseReturnsOnCall(i int, result1 error) {
	fake.removeProductFileFromReleaseMutex.Lock()
	defer fake.removeProductFileFromReleaseMutex.Unlock()
	fake.RemoveProductFileFromReleaseStub = nil
	if fake.removeProductFileFromReleaseReturnsOnCall == nil {
		fake.removeProductFileFromReleaseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeProductFileFromReleaseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) UpdateProductFile(arg1 string, arg2 pivnet.ProductFile) (pivnet.ProductFile, error) {
	fake.updateProductFileMutex.Lock()
	ret, specificReturn := fake.updateProductFileReturnsOnCall[len(fake.updateProductFileArgsForCall)]
	fake.updateProductFileArgsForCall = append(fake.updateProductFileArgsForCall, struct {
		arg1 string
		arg2 pivnet.ProductFile
	}{arg1, arg2})
	fake.recordInvocation("UpdateProductFile", []interface{}{arg1, arg2})
	fake.updateProductFileMutex.Unlock()
	if fake.UpdateProductFileStub != nil {
		return fake.UpdateProductFileStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateProductFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) UpdateProductFileCallCount() int {
	fake.updateProductFileMutex.RLock()
	defer fake.updateProductFileMutex.RUnlock()
	return len(fake.updateProductFileArgsForCall)
}

func (fake *FakePivnetClient) UpdateProductFileCalls(stub func(string, pivnet.ProductFile) (pivnet.ProductFile, error)) {
	fake.updateProductFileMutex.Lock()
	defer fake.updateProductFileMutex.Unlock()
	fake.UpdateProductFileStub = stub
}

func (fake *FakePivnetClient) UpdateProductFileArgsForCall(i int) (string, pivnet.ProductFile) {
	fake.updateProductFileMutex.RLock()
	defer fake.updateProductFileMutex.RUnlock()
	argsForCall := fake.updateProductFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) UpdateProductFileReturns(result1 pivnet.ProductFile, result2 error) {
	fake.updateProductFileMutex.Lock()
	defer fake.updateProductFileMutex.Unlock()
	fake.UpdateProductFileStub = nil
	fake.updateProductFileReturns = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) UpdateProductFileReturnsOnCall(i int, result1 pivnet.ProductFile, result2 error) {
	fake.updateProductFileMutex.Lock()
	defer fake.updateProductFileMutex.Unlock()
	fake.UpdateProductFileStub = nil
	if fake.updateProductFileReturnsOnCall == nil {
		fake.updateProductFileReturnsOnCall = make(map[int]struct {
			result1 pivnet.ProductFile
			result2 error
		})
	}
	fake.updateProductFileReturnsOnCall[i] = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.acceptEULAMutex.RLock()
	defer fake.acceptEULAMutex.RUnlock()
	fake.addProductFileToFileGroupMutex.RLock()
	defer fake.addProductFileToFileGroupMutex.RUnlock()
	fake.addProductFileToReleaseMutex.RLock()
	defer fake.addProductFileToReleaseMutex.RUnlock()
	fake.createProductFileMutex.RLock()
	defer fake.createProductFileMutex.RUnlock()
	fake.deleteProductFileMutex.RLock()
	defer fake.deleteProductFileMutex.RUnlock()
	fake.downloadProductFileMutex.RLock()
	defer fake.downloadProductFileMutex.RUnlock()
	fake.productFileMutex.RLock()
	defer fake.productFileMutex.RUnlock()
	fake.productFileForReleaseMutex.RLock()
	defer fake.productFileForReleaseMutex.RUnlock()
	fake.productFilesMutex.RLock()
	defer fake.productFilesMutex.RUnlock()
	fake.productFilesForReleaseMutex.RLock()
	defer fake.productFilesForReleaseMutex.RUnlock()
	fake.releaseForVersionMutex.RLock()
	defer fake.releaseForVersionMutex.RUnlock()
	fake.removeProductFileFromFileGroupMutex.RLock()
	defer fake.removeProductFileFromFileGroupMutex.RUnlock()
	fake.removeProductFileFromReleaseMutex.RLock()
	defer fake.removeProductFileFromReleaseMutex.RUnlock()
	fake.updateProductFileMutex.RLock()
	defer fake.updateProductFileMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePivnetClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ productfile.PivnetClient = new(FakePivnetClient)
